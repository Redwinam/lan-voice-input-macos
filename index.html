<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Ë®Ä‰º†</title>
    <meta name="application-name" content="Ë®Ä‰º†" />
    <meta name="keywords" content="Ë®Ä‰º†, Â±ÄÂüüÁΩëËØ≠Èü≥ËæìÂÖ•Ê≥ï, Â±ÄÂüüÁΩëËØ≠Èü≥ËæìÂÖ•, LAN Voice Input" />
    <style>
      :root {
        --primary: #3b82f6; /* Blue 500 */
        --primary-hover: #2563eb; /* Blue 600 */
        --bg: #f1f5f9; /* Slate 100 */
        --surface: #ffffff;
        --text: #1e293b; /* Slate 800 */
        --text-secondary: #64748b; /* Slate 500 */
        --border: #e2e8f0; /* Slate 200 */
        --success: #10b981; /* Emerald 500 */
        --error: #ef4444; /* Red 500 */
        --warning: #f59e0b; /* Amber 500 */
        --radius: 16px;
        --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
        --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        --font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      }

      * {
        box-sizing: border-box;
        -webkit-tap-highlight-color: transparent;
      }

      body {
        margin: 0;
        padding: 0;
        font-family: var(--font-family);
        background: var(--bg);
        color: var(--text);
        height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        overflow: hidden; /* Prevent body scroll, handle inside container */
      }

      .container {
        width: 100%;
        max-width: 640px;
        height: 100%;
        display: flex;
        flex-direction: column;
        padding: 16px;
        gap: 12px;
        overflow: scroll;
      }

      /* Header */
      header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0 6px;
      }

      h1 {
        margin: 0;
        font-size: 18px;
        font-weight: 700;
        background: linear-gradient(135deg, #3b82f6 0%, #8b5cf6 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        letter-spacing: -0.5px;
      }

      .status-badge {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 12px;
        font-weight: 600;
        padding: 6px 12px;
        background: var(--surface);
        border-radius: 999px;
        box-shadow: var(--shadow-sm);
        color: var(--text-secondary);
        border: 1px solid var(--border);
        transition: all 0.3s ease;
      }

      .status-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: var(--text-secondary);
        transition: background 0.3s;
      }

      .status-badge.connected {
        border-color: var(--success);
        color: var(--success);
        background: #ecfdf5;
      }
      .status-badge.connected .status-dot {
        background: var(--success);
        box-shadow: 0 0 8px var(--success);
      }

      .status-badge.disconnected {
        border-color: var(--error);
        color: var(--error);
        background: #fef2f2;
      }
      .status-badge.disconnected .status-dot {
        background: var(--error);
      }

      .status-badge.connecting {
        border-color: var(--warning);
        color: var(--warning);
        background: #fffbeb;
      }
      .status-badge.connecting .status-dot {
        background: var(--warning);
        animation: pulse 1.5s infinite;
      }

      @keyframes pulse {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
        100% {
          opacity: 1;
        }
      }

      /* Main Card */
      .card {
        background: var(--surface);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 16px;
        /* flex: 1; */
        /* min-height: 0; */
        position: relative;
      }

      /* Send Mode Tabs (Top) */
      .send-mode-tabs {
        display: flex;
        background: var(--bg);
        padding: 4px;
        border-radius: 12px;
      }

      .tab-btn {
        flex: 1;
        border: none;
        background: transparent;
        padding: 8px;
        font-size: 14px;
        font-weight: 600;
        color: var(--text-secondary);
        cursor: pointer;
        border-radius: 8px;
        transition: all 0.2s;
      }

      .tab-btn.active {
        background: var(--surface);
        color: var(--primary);
        box-shadow: var(--shadow-sm);
      }

      /* Input & Button Container (Side-by-Side) */
      .input-row {
        display: flex;
        gap: 12px;
        height: 136px; /* Fixed height for consistency */
      }

      .input-wrapper {
        flex: 1;
        height: 100%;
        position: relative;
      }

      textarea {
        width: 100%;
        height: 100%;
        border: 2px solid transparent;
        border-radius: 12px;
        background: #f8fafc;
        padding: 16px;
        font-size: 18px;
        line-height: 1.6;
        resize: none;
        outline: none;
        transition: all 0.2s;
        color: var(--text);
        font-family: inherit;
      }

      textarea:focus {
        background: var(--surface);
        border-color: var(--primary);
        box-shadow: 0 0 0 4px rgba(59, 130, 246, 0.1);
      }

      textarea::placeholder {
        color: #94a3b8;
      }

      /* Vertical Button Stack */
      .btn-stack {
        display: flex;
        flex-direction: column;
        gap: 8px;
        width: 90px; /* Fixed width for buttons */
      }

      .btn {
        border: none;
        border-radius: 10px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
        flex: 1; /* Distribute height equally */
        padding: 0;
      }

      .btn:active {
        transform: scale(0.96);
      }

      .btn-primary {
        background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
        color: white;
        box-shadow: 0 2px 4px rgba(37, 99, 235, 0.2);
      }

      .btn-secondary {
        background: white;
        color: var(--text);
        border: 1px solid var(--border);
      }
      .btn-secondary:hover {
        background: #f8fafc;
      }

      /* Mode Toggle Area (Bottom) */
      .mode-toggle-area {
        display: flex;
        align-items: center;
        justify-content: flex-end;
        flex-wrap: wrap;
        gap: 12px;
      }

      .toggle-wrapper {
        display: flex;
        align-items: center;
        gap: 7px;
        flex: 0 0 auto;
        justify-content: flex-end;
      }

      .toggle-switch-label {
        position: relative;
        display: inline-block;
        width: 42px;
        height: 20px;
      }

      .toggle-switch-label input {
        opacity: 0;
        width: 0;
        height: 0;
      }

      .slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #cbd5e1;
        transition: 0.4s;
        border-radius: 34px;
      }

      .slider:before {
        position: absolute;
        content: "";
        height: 14px;
        width: 14px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        transition: 0.4s;
        border-radius: 50%;
        box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
      }

      input:checked + .slider {
        background-color: var(--warning); /* Use warning color for Command Mode to differentiate */
      }

      input:checked + .slider:before {
        transform: translateX(22px);
      }

      .mode-label {
        font-size: 14px;
        font-weight: 600;
        color: var(--text);
      }

      .help-icon {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #e2e8f0;
        color: #64748b;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 12px;
        font-weight: bold;
        cursor: help;
        position: relative;
      }

      .popover {
        position: absolute;
        bottom: 30px;
        right: 0; /* Align right */
        left: auto;
        transform: none;
        width: 240px;
        padding: 12px;
        background: #1e293b;
        color: white;
        font-size: 12px;
        border-radius: 8px;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        opacity: 0;
        visibility: hidden;
        transition: all 0.2s;
        z-index: 10;
        text-align: left; /* Left align text */
        line-height: 1.4;
      }

      .help-icon:hover .popover,
      .help-icon:active .popover,
      .help-icon.active .popover {
        opacity: 1;
        visibility: visible;
        bottom: 36px;
      }

      .popover::after {
        content: "";
        position: absolute;
        top: 100%;
        right: 6px; /* Align arrow with icon */
        left: auto;
        margin-left: 0;
        border-width: 6px;
        border-style: solid;
        border-color: #1e293b transparent transparent transparent;
      }

      /* Log Area */
      .log-wrapper {
        flex: 1; /* Fill remaining space */
        min-height: 100px;
        background: #1e293b; /* Slate 800 */
        border-radius: var(--radius);
        overflow: hidden;
        display: flex;
        flex-direction: column;
        flex-shrink: 0;
        box-shadow: var(--shadow);
      }

      /* Responsive Button Icons */
      .btn-icon {
        display: none;
        margin-right: 6px;
      }
      @media (min-width: 600px) {
        .btn-icon {
          display: inline;
        }
      }

      .log-header {
        padding: 8px 12px;
        background: #0f172a; /* Slate 900 */
        color: #94a3b8;
        font-size: 11px;
        font-weight: 700;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        display: flex;
        justify-content: space-between;
      }

      .log-content {
        flex: 1;
        padding: 12px;
        overflow-y: auto;
        font-family: "JetBrains Mono", "Menlo", "Monaco", monospace;
        font-size: 12px;
        line-height: 1.5;
        color: #cbd5e1;
      }

      .log-entry {
        margin-bottom: 6px;
        word-break: break-all;
        animation: fadeIn 0.2s ease-out;
      }
      .log-time {
        color: #64748b;
        margin-right: 8px;
        user-select: none;
      }
      .log-msg {
        color: #e2e8f0;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(5px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      /* Scrollbar */
      ::-webkit-scrollbar {
        width: 6px;
        height: 6px;
      }
      ::-webkit-scrollbar-track {
        background: transparent;
      }
      ::-webkit-scrollbar-thumb {
        background: #cbd5e1;
        border-radius: 3px;
      }
      .log-content::-webkit-scrollbar-thumb {
        background: #475569;
      }

      .icon-btn {
        background: transparent;
        border: none;
        cursor: pointer;
        padding: 6px;
        border-radius: 6px;
        color: #94a3b8;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
      }

      .icon-btn:hover {
        color: var(--text);
        background: rgba(0, 0, 0, 0.04);
      }

      .icon-btn:active {
        transform: scale(0.92);
      }

      .icon-btn:active svg {
        transform: rotate(180deg);
      }

      .icon-btn svg {
        transition: transform 0.3s ease;
      }

      .header-right {
        display: flex;
        align-items: center;
        gap: 7px;
      }

      .func-btn-group {
        display: flex;
        gap: 7px;
        align-items: center;
        flex: 1;
        justify-content: flex-start;
        margin-top: -4px;
      }

      .func-btn {
        background: linear-gradient(180deg, #f1f5f9 0%, #e2e8f0 100%);
        border: none;
        border-radius: 6px;
        padding: 6px 12px 5px 12px;
        font-size: 11px;
        font-weight: 600;
        font-family: "JetBrains Mono", "Menlo", "Monaco", monospace;
        color: #475569;
        cursor: pointer;
        box-shadow:
          0 1px 0 0 #fff inset,
          0 -1px 0 0 #cbd5e1 inset,
          0 2px 0 0 #94a3b8;
        transition: all 0.1s ease;
        min-width: auto;
        letter-spacing: 0.5px;
        text-transform: uppercase;
      }

      .func-btn:hover {
        background: linear-gradient(180deg, #f8fafc 0%, #e2e8f0 100%);
        color: #334155;
      }

      .func-btn:active {
        background: linear-gradient(180deg, #e2e8f0 0%, #cbd5e1 100%);
        box-shadow:
          0 1px 0 0 #e2e8f0 inset,
          0 -1px 0 0 #94a3b8 inset,
          0 1px 0 0 #94a3b8;
        transform: translateY(1px);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>üéôÔ∏è Ë®Ä‰º†</h1>
        <div class="header-right">
          <div class="status-badge disconnected" id="statusBadge">
            <div class="status-dot"></div>
            <span id="statusText">Ê£ÄÊµã‰∏≠</span>
          </div>
          <button id="refreshBtn" class="icon-btn" title="ÂÅ•Â∫∑Ê£ÄÊü•/ÈáçËøû">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
              <path d="M23 4v6h-6"></path>
              <path d="M1 20v-6h6"></path>
              <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
            </svg>
          </button>
        </div>
      </header>

      <div class="card">
        <!-- Send Mode Tabs -->
        <div class="send-mode-tabs">
          <button class="tab-btn" id="tabAuto">‚ö° Ëá™Âä®ÂèëÈÄÅ</button>
          <button class="tab-btn active" id="tabManual">üì§ ÊâãÂä®ÂèëÈÄÅ</button>
        </div>

        <!-- Input and Buttons Row -->
        <form class="input-row" id="sendForm">
          <div class="input-wrapper">
            <textarea id="inputBox" placeholder="ÁÇπÂáªÊ≠§Â§ÑÔºåÂºÄÂßãËØ≠Èü≥ËæìÂÖ•..." enterkeyhint="send"></textarea>
          </div>
          <div class="btn-stack">
            <button id="sendBtn" class="btn btn-primary" type="submit">ÂèëÈÄÅ</button>
            <button id="resendBtn" class="btn btn-secondary" type="button">ÈáçÂèë</button>
            <button id="clearBtn" class="btn btn-secondary" type="button">Ê∏ÖÁ©∫</button>
            <button id="testBtn" class="btn btn-secondary" type="button" style="display: none">ÊµãËØï</button>
          </div>
        </form>

        <!-- Mode Toggle (Text/Cmd) -->
        <div class="mode-toggle-area">
          <div class="func-btn-group">
            <button class="func-btn" data-cmd="esc">ESC</button>
            <button class="func-btn" data-cmd="tab">TAB</button>
            <button class="func-btn" data-cmd="enter">ENTER</button>
          </div>

          <div class="toggle-wrapper">
            <label class="toggle-switch-label">
              <input type="checkbox" id="modeToggle" />
              <span class="slider"></span>
            </label>
            <span class="mode-label" id="modeLabel">‚úçÔ∏è ÊñáÂ≠óÊ®°Âºè</span>
            <div class="help-icon">
              ?
              <div class="popover">
                <b>ÊñáÂ≠óÊ®°Âºè</b>: ÊôÆÈÄöËæìÂÖ•<br />
                <b>ÂëΩ‰ª§Ê®°Âºè</b>: ÂèëÈÄÅÊåá‰ª§ (Â¶Ç "ÂõûËΩ¶", "Âà†Èô§")
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="log-wrapper">
        <div class="log-header">
          <span>System Log</span>
          <span style="cursor: pointer" onclick="document.getElementById('log').innerHTML = ''">CLEAR</span>
        </div>
        <div class="log-content" id="log"></div>
      </div>
    </div>

    <script>
      let ws;
      let timer = null;
      let isComposing = false;
      let currentMode = "text";
      let isConnecting = false;
      let manualClosing = false;
      let isManualSendMode = true; // Default to Manual

      let lastSentText = "";
      let lastSentMsg = "";
      let lastSentTime = 0;
      let lastManualText = "";
      const DUP_WINDOW_MS = 1500;

      const MAX_LOG_LINES = 100;
      let reconnectTimer = null;
      let reconnectAttempt = 0;
      let pendingConnectToken = 0;
      let dialingWs = null;
      const CONNECT_TIMEOUT_MS = 2500;
      const RECONNECT_BASE_MS = 500;
      const RECONNECT_MAX_MS = 5000;
      const RECONNECT_JITTER_MS = 300;
      const WS_PORT_CACHE_KEY = "lanvoice_ws_port";
      const SEND_MODE_CACHE_KEY = "lanvoice_send_mode";
      const INPUT_MODE_CACHE_KEY = "lanvoice_input_mode";
      const HEALTH_CHECK_INTERVAL_MS = 3000;
      const HEALTH_CHECK_TIMEOUT_MS = 1200;
      let healthTimer = null;
      let lastInputFocused = false;

      function log(msg) {
        const el = document.getElementById("log");
        const time = new Date().toLocaleTimeString("en-US", { hour12: false, hour: "2-digit", minute: "2-digit", second: "2-digit" });

        const div = document.createElement("div");
        div.className = "log-entry";
        div.innerHTML = `<span class="log-time">[${time}]</span><span class="log-msg">${msg}</span>`;

        el.insertBefore(div, el.firstChild);

        if (el.children.length > MAX_LOG_LINES) {
          el.removeChild(el.lastChild);
        }
      }

      function setStatus(msg, type = "normal") {
        const badge = document.getElementById("statusBadge");
        const text = document.getElementById("statusText");

        text.textContent = msg;
        badge.className = "status-badge";

        if (type === "online") {
          badge.classList.add("connected");
        } else if (type === "offline") {
          badge.classList.add("disconnected");
        } else if (type === "checking") {
          badge.classList.add("connecting");
        } else if (msg.includes("Â∑≤ËøûÊé•")) {
          badge.classList.add("connected");
        } else if (msg.includes("Êñ≠ÂºÄ") || msg.includes("ÈîôËØØ")) {
          badge.classList.add("disconnected");
        } else if (msg.includes("ËøûÊé•") || msg.includes("‰∏≠")) {
          badge.classList.add("connecting");
        }
      }

      // Send Mode Logic
      function setSendMode(manual) {
        isManualSendMode = manual;
        document.getElementById("tabAuto").classList.toggle("active", !manual);
        document.getElementById("tabManual").classList.toggle("active", manual);
        localStorage.setItem(SEND_MODE_CACHE_KEY, manual ? "manual" : "auto");
        log("‚ÑπÔ∏è ÂàáÊç¢‰∏∫Ôºö" + (manual ? "ÊâãÂä®ÂèëÈÄÅ" : "Ëá™Âä®ÂèëÈÄÅ"));
        if (manual) {
          startHealthPolling();
          stopWsDialing();
          if (ws && (ws.readyState === 0 || ws.readyState === 1)) {
            manualClosing = true;
            ws.close();
          }
        } else {
          stopHealthPolling();
          setStatus("ËøûÊé•‰∏≠", "checking");
          connectWS(true);
        }
      }

      document.getElementById("tabAuto").onclick = () => setSendMode(false);
      document.getElementById("tabManual").onclick = () => setSendMode(true);

      // Text/Cmd Mode Logic
      function toggleInputMode() {
        const isCmd = document.getElementById("modeToggle").checked;
        currentMode = isCmd ? "cmd" : "text";
        localStorage.setItem(INPUT_MODE_CACHE_KEY, currentMode);
        document.getElementById("modeLabel").textContent = isCmd ? "‚å®Ô∏è ÂëΩ‰ª§Ê®°Âºè" : "‚úçÔ∏è ÊñáÂ≠óÊ®°Âºè";
        log("‚úÖ ÂàáÊç¢Ê®°ÂºèÔºö" + (isCmd ? "ÂëΩ‰ª§" : "ÊñáÂ≠ó"));
      }

      document.getElementById("modeToggle").onchange = toggleInputMode;
      const savedSendMode = localStorage.getItem(SEND_MODE_CACHE_KEY);
      if (savedSendMode === "auto" || savedSendMode === "manual") {
        setSendMode(savedSendMode === "manual");
      }
      const savedInputMode = localStorage.getItem(INPUT_MODE_CACHE_KEY);
      if (savedInputMode === "cmd" || savedInputMode === "text") {
        const modeToggle = document.getElementById("modeToggle");
        modeToggle.checked = savedInputMode === "cmd";
        toggleInputMode();
      }

      // Popover click handling for mobile
      const helpIcon = document.querySelector(".help-icon");
      helpIcon.addEventListener("click", (e) => {
        e.stopPropagation();
        helpIcon.classList.toggle("active");
      });
      document.addEventListener("click", () => {
        helpIcon.classList.remove("active");
      });

      function getWSFromQuery() {
        const url = new URL(location.href);
        return url.searchParams.get("ws");
      }

      function normalizePort(port) {
        if (port === undefined || port === null) return null;
        const value = String(port).trim();
        return value ? value : null;
      }

      async function fetchWSPortWithTimeout(timeoutMs) {
        const controller = new AbortController();
        const timerId = setTimeout(() => controller.abort(), timeoutMs);
        try {
          const res = await fetch("/config", { signal: controller.signal, cache: "no-store" });
          const cfg = await res.json();
          return normalizePort(cfg && cfg.ws_port);
        } catch (e) {
          return null;
        } finally {
          clearTimeout(timerId);
        }
      }

      async function resolveWSPortCandidates() {
        const candidates = [];
        const sources = [];
        const wsFromQuery = normalizePort(getWSFromQuery());
        if (wsFromQuery) {
          candidates.push(wsFromQuery);
          sources.push(`query=${wsFromQuery}`);
        }
        const cached = normalizePort(localStorage.getItem(WS_PORT_CACHE_KEY));
        if (cached) {
          candidates.push(cached);
          sources.push(`cache=${cached}`);
        }
        const configPort = await fetchWSPortWithTimeout(800);
        if (configPort) {
          candidates.push(configPort);
          sources.push(`config=${configPort}`);
        }
        candidates.push("8765");
        sources.push("default=8765");
        log("üîé WS ÂÄôÈÄâÁ´ØÂè£Ôºö" + sources.join(", "));
        return [...new Set(candidates)];
      }

      async function fetchHealthWithTimeout(timeoutMs) {
        const controller = new AbortController();
        const timerId = setTimeout(() => controller.abort(), timeoutMs);
        try {
          const res = await fetch("/health", { signal: controller.signal, cache: "no-store" });
          if (!res.ok) return null;
          return await res.json();
        } catch (e) {
          return null;
        } finally {
          clearTimeout(timerId);
        }
      }

      async function checkHealth(announce = false) {
        setStatus("Ê£ÄÊµã‰∏≠", "checking");
        const data = await fetchHealthWithTimeout(HEALTH_CHECK_TIMEOUT_MS);
        if (data && data.ok) {
          setStatus("Âú®Á∫ø", "online");
          if (announce) log("‚úÖ ÂÅ•Â∫∑Ê£ÄÊü•ÈÄöËøá");
        } else {
          setStatus("Á¶ªÁ∫ø", "offline");
          if (announce) log("‚ùå ÂÅ•Â∫∑Ê£ÄÊü•Â§±Ë¥•");
        }
      }

      function startHealthPolling() {
        if (healthTimer) return;
        checkHealth();
        healthTimer = setInterval(checkHealth, HEALTH_CHECK_INTERVAL_MS);
      }
      function stopHealthPolling() {
        if (!healthTimer) return;
        clearInterval(healthTimer);
        healthTimer = null;
      }

      function scheduleReconnect() {
        if (manualClosing || isManualSendMode) return;
        if (reconnectTimer) return;
        const delay = Math.min(RECONNECT_MAX_MS, RECONNECT_BASE_MS * Math.pow(2, reconnectAttempt));
        const jitter = Math.floor(Math.random() * RECONNECT_JITTER_MS);
        const wait = delay + jitter;
        reconnectAttempt += 1;
        log("üîÑ " + Math.round(wait / 1000) + "s ÂêéÈáçËøû...");
        reconnectTimer = setTimeout(() => {
          reconnectTimer = null;
          connectWS();
        }, wait);
      }

      function attachWsRuntimeHandlers() {
        if (!ws) return;
        ws.onclose = (event) => {
          isConnecting = false;
          if (manualClosing) {
            manualClosing = false;
            log("üîå Â∑≤ÊâãÂä®Êñ≠ÂºÄ");
            return;
          }
          const code = event && typeof event.code === "number" ? event.code : "unknown";
          const reason = event && typeof event.reason === "string" ? event.reason : "";
          log("‚ùå ËøûÊé•Êñ≠ÂºÄ code=" + code + (reason ? " reason=" + reason : ""));
          if (!isManualSendMode) setStatus("Á¶ªÁ∫ø", "offline");
          scheduleReconnect();
        };

        ws.onerror = () => {
          isConnecting = false;
          const state = ws ? ws.readyState : -1;
          log("‚ùå WebSocket ÈîôËØØ state=" + state);
          if (!isManualSendMode) setStatus("Á¶ªÁ∫ø", "offline");
          if (!manualClosing) scheduleReconnect();
        };

        ws.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            if (data && data.type === "cmd_result") {
              log("‚úÖ ÂëΩ‰ª§ÁªìÊûúÔºö" + data.message);
            }
          } catch (e) {}
        };
      }

      function tryConnectPort(port, connectId) {
        return new Promise((resolve) => {
          const wsUrl = `ws://${location.hostname}:${port}`;
          const startedAt = Date.now();
          log("‚è≥ Ê≠£Âú®ËøûÊé•Âà∞Ôºö" + wsUrl);
          let finished = false;
          let wsInstance = null;
          let timeoutId = setTimeout(() => {
            if (finished) return;
            finished = true;
            try {
              if (wsInstance && wsInstance.readyState !== 3) wsInstance.close();
            } catch (e) {}
            const state = wsInstance ? wsInstance.readyState : -1;
            log("‚è±Ô∏è ËøûÊé•Ë∂ÖÊó∂Ôºö" + wsUrl + " state=" + state);
            resolve(false);
          }, CONNECT_TIMEOUT_MS);

          try {
            wsInstance = new WebSocket(wsUrl);
          } catch (e) {
            clearTimeout(timeoutId);
            log("‚ùå ÂàõÂª∫ËøûÊé•Â§±Ë¥•Ôºö" + wsUrl);
            resolve(false);
            return;
          }
          dialingWs = wsInstance;

          const cleanup = () => {
            if (timeoutId) {
              clearTimeout(timeoutId);
              timeoutId = null;
            }
          };

          wsInstance.onopen = () => {
            if (finished) return;
            finished = true;
            cleanup();
            if (connectId !== pendingConnectToken) {
              try {
                wsInstance.close();
              } catch (e) {}
              log("‚ö†Ô∏è ËøûÊé•Ë¢´Êñ∞ËØ∑Ê±ÇÊõøÊç¢Ôºö" + wsUrl);
              resolve(false);
              return;
            }
            isConnecting = false;
            manualClosing = false;
            reconnectAttempt = 0;
            localStorage.setItem(WS_PORT_CACHE_KEY, String(port));
            ws = wsInstance;
            if (dialingWs === wsInstance) dialingWs = null;
            log("‚úÖ Â∑≤ËøûÊé•Âà∞ÊúçÂä°Âô®Ôºà" + (Date.now() - startedAt) + "msÔºâ");
            if (!isManualSendMode) setStatus("Â∑≤ËøûÊé•", "online");
            attachWsRuntimeHandlers();
            resolve(true);
          };

          wsInstance.onclose = (event) => {
            if (finished) return;
            finished = true;
            cleanup();
            const code = event && typeof event.code === "number" ? event.code : "unknown";
            const reason = event && typeof event.reason === "string" ? event.reason : "";
            log("‚ùå ËøûÊé•ÂÖ≥Èó≠Ôºö" + wsUrl + " code=" + code + (reason ? " reason=" + reason : ""));
            if (dialingWs === wsInstance) dialingWs = null;
            resolve(false);
          };

          wsInstance.onerror = () => {
            if (finished) return;
            finished = true;
            cleanup();
            const state = wsInstance ? wsInstance.readyState : -1;
            log("‚ùå ËøûÊé•ÈîôËØØÔºö" + wsUrl + " state=" + state);
            if (dialingWs === wsInstance) dialingWs = null;
            resolve(false);
          };
        });
      }

      async function connectWS(force = false) {
        if (isManualSendMode) return;
        if (isConnecting && !force) return;
        isConnecting = true;
        if (force) {
          pendingConnectToken += 1;
        }
        const connectId = ++pendingConnectToken;
        log("üß≠ ÂºÄÂßãËøûÊé•Ôºàforce=" + (force ? "1" : "0") + "Ôºâ");
        if (reconnectTimer) {
          clearTimeout(reconnectTimer);
          reconnectTimer = null;
        }
        if (force) {
          try {
            if (ws && (ws.readyState === 0 || ws.readyState === 1)) {
              manualClosing = true;
              ws.close();
            }
          } catch (e) {}
          try {
            if (dialingWs && dialingWs.readyState !== 3) dialingWs.close();
          } catch (e) {}
        }
        const candidates = await resolveWSPortCandidates();
        for (const port of candidates) {
          if (connectId !== pendingConnectToken) return;
          const ok = await tryConnectPort(port, connectId);
          if (ok) return;
        }
        log("‚ö†Ô∏è ÊâÄÊúâÂÄôÈÄâÁ´ØÂè£ËøûÊé•Â§±Ë¥•");
        isConnecting = false;
        scheduleReconnect();
      }
      if (!isManualSendMode) connectWS();
      if (isManualSendMode) startHealthPolling();

      window.onload = () => {
        setTimeout(() => document.getElementById("inputBox").focus(), 200);
      };

      window.addEventListener("online", () => {
        if (!isManualSendMode && (!ws || ws.readyState !== 1)) connectWS();
      });

      document.addEventListener("visibilitychange", () => {
        if (!isManualSendMode && !document.hidden && (!ws || ws.readyState !== 1)) connectWS();
      });

      async function sendPayload(type, text, force = false, useHttp = false) {
        text = (text || "").trim();
        if (!text) return;

        const now = Date.now();
        const dedupKey = type + "::" + text;
        if (!force && dedupKey === lastSentMsg && now - lastSentTime < DUP_WINDOW_MS) {
          log("‚è≠Ô∏è ÂøΩÁï•ÈáçÂ§çÂèëÈÄÅ");
          return;
        }
        lastSentMsg = dedupKey;
        lastSentTime = now;

        const payload = { type, string: text };
        if (useHttp) {
          try {
            const res = await fetch("/send", {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(payload),
              cache: "no-store",
            });
            if (!res.ok) {
              log("‚ö†Ô∏è ÂèëÈÄÅÂ§±Ë¥•");
              return;
            }
            const data = await res.json().catch(() => null);
            if (data && data.type === "cmd_result") {
              log("‚úÖ ÂëΩ‰ª§ÁªìÊûúÔºö" + data.message);
            } else {
              log("üì§ " + (type === "text" ? "ÂèëÈÄÅ" : "ÂëΩ‰ª§") + "Ôºö" + text);
            }
          } catch (e) {
            log("‚ö†Ô∏è ÂèëÈÄÅÂ§±Ë¥•");
          }
          return;
        }

        if (ws && ws.readyState === 1) {
          ws.send(JSON.stringify(payload));
          log("üì§ " + (type === "text" ? "ÂèëÈÄÅ" : "ÂëΩ‰ª§") + "Ôºö" + text);
        } else {
          log("‚ö†Ô∏è Êú™ËøûÊé•ÔºåÂèëÈÄÅÂ§±Ë¥•");
        }
      }

      function sendText(text, force = false, useHttp = false) {
        return sendPayload(currentMode, text, force, useHttp);
      }

      function handleManualSend() {
        const box = document.getElementById("inputBox");
        const text = box.value;
        if (text) {
          lastManualText = text;
          sendText(text, false, isManualSendMode);
          box.value = "";
          lastSentText = "";
          box.focus();
        } else {
          log("‚ö†Ô∏è ÂÜÖÂÆπ‰∏∫Á©∫");
        }
      }

      document.getElementById("sendForm").addEventListener("submit", (e) => {
        e.preventDefault();
        handleManualSend();
      });

      document.getElementById("resendBtn").onclick = () => {
        if (!lastManualText) {
          log("‚ö†Ô∏è Êó†ÂéÜÂè≤ÂÜÖÂÆπ");
          return;
        }
        log("üîÑ ÈáçÂèë...");
        sendText(lastManualText, true, isManualSendMode);
      };

      document.getElementById("refreshBtn").onclick = async () => {
        if (isManualSendMode) {
          log("üîå ÂÅ•Â∫∑Ê£ÄÊü•...");
          checkHealth(true);
          return;
        }
        log("üîå ÈáçËøû...");
        reconnectAttempt = 0;
        connectWS(true);
      };

      function stopWsDialing() {
        if (reconnectTimer) {
          clearTimeout(reconnectTimer);
          reconnectTimer = null;
        }
        reconnectAttempt = 0;
        pendingConnectToken += 1;
        isConnecting = false;
        try {
          if (dialingWs && dialingWs.readyState !== 3) dialingWs.close();
        } catch (e) {}
        dialingWs = null;
      }

      const inputBox = document.getElementById("inputBox");
      document.querySelectorAll(".func-btn").forEach((btn) => {
        btn.onmousedown = () => {
          lastInputFocused = document.activeElement === inputBox;
        };
        btn.onclick = (e) => {
          e.preventDefault();
          const cmd = btn.dataset.cmd;
          if (!cmd) return;

          const map = {
            enter: "ÂõûËΩ¶",
            tab: "tab",
            esc: "esc",
          };
          const text = map[cmd] || cmd;
          sendPayload("text", text, true, isManualSendMode);
          if (lastInputFocused) {
            inputBox.focus();
            lastInputFocused = false;
          }
        };
      });

      document.getElementById("clearBtn").onclick = () => {
        const box = document.getElementById("inputBox");
        box.value = "";
        lastSentText = "";
        document.getElementById("log").innerHTML = "";
        box.focus();
      };

      document.getElementById("testBtn").onclick = () => {
        log("üß™ ÊµãËØïÊ≥®ÂÖ•Êåá‰ª§");
        sendText("__TEST_INJECT__");
      };

      inputBox.addEventListener("compositionstart", () => (isComposing = true));
      inputBox.addEventListener("compositionend", () => {
        isComposing = false;
        flushDelta();
      });
      inputBox.addEventListener("keydown", (e) => {
        if (isManualSendMode && e.key === "Enter" && !e.shiftKey && !isComposing) {
          e.preventDefault();
          const form = document.getElementById("sendForm");
          if (form.requestSubmit) {
            form.requestSubmit();
          } else {
            form.dispatchEvent(new Event("submit", { cancelable: true }));
          }
        }
      });

      inputBox.addEventListener("input", () => {
        clearTimeout(timer);
        if (isComposing) return;
        timer = setTimeout(flushDelta, 500);
      });

      function flushDelta() {
        // Check global variable instead of checkbox
        if (isManualSendMode) return;

        const current = inputBox.value;
        if (!current.trim()) return;

        if (current.startsWith(lastSentText)) {
          const delta = current.slice(lastSentText.length).trim();
          if (delta) {
            sendText(delta);
            lastSentText = current;
          }
        } else {
          log("‚úèÔ∏è Ê£ÄÊµãÂà∞ÂéÜÂè≤ÁºñËæëÔºåËØ∑ÊâãÂä®ÂèëÈÄÅ");
        }
      }
    </script>
  </body>
</html>
